## 算法

包含动态规划，贪心，深度搜索优先，二分查找，广度搜索优先，回溯，递归，分治，记忆化搜索，归并排序，快速选择。



## 一、动态规划
# 3473. Sum of K Subarrays With Length at Least M
中等


## 提示
You are given an integer array `nums` and two integers `k` and `m`.

Return the maximum sum of `k` non-overlapping subarrays of `nums`, where each subarray has a length of at least `m`.

### Example 1:

**Input:** `nums = [1,2,-1,3,3,4], k = 2, m = 2`

**Output:** `13`

**Explanation:**

The optimal choice is:

Subarray `nums[3..5]` with sum `3 + 3 + 4 = 10` (length is 3 >= m).  
Subarray `nums[0..1]` with sum `1 + 2 = 3` (length is 2 >= m).  
The total sum is `10 + 3 = 13`.


## Constraints:

- `1 <= nums.length <= 2000`
- `-10^4 <= nums[i] <= 10^4`
- `1 <= k <= floor(nums.length / m)`
- `1 <= m <= 3`


## 二、贪心
# 3402. Minimum Operations to Make Columns Strictly Increasing
简单


## 提示
You are given a `m x n` matrix `grid` consisting of non-negative integers.

In one operation, you can increment the value of any `grid[i][j]` by 1.

Return the minimum number of operations needed to make all columns of `grid` strictly increasing.

### Example 1:

**Input:** `grid = [[3,2],[1,3],[3,4],[0,1]]`

**Output:** `15`

**Explanation:**

To make the 0th column strictly increasing, we can apply 3 operations on `grid[1][0]`, 2 operations on `grid[2][0]`, and 6 operations on `grid[3][0]`.  
To make the 1st column strictly increasing, we can apply 4 operations on `grid[3][1]`.



## Constraints:

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 50`
- `0 <= grid[i][j] < 2500`




# 3462. Maximum Sum With at Most K Elements
中等

## 提示
You are given a `2D` integer matrix `grid` of size `n x m`, an integer array `limits` of length `n`, and an integer `k`. The task is to find the maximum sum of at most `k` elements from the matrix `grid` such that:

The number of elements taken from the `i`th row of `grid` does not exceed `limits[i]`.

Return the maximum sum.

### Example 1:

**Input:** `grid = [[1,2],[3,4]], limits = [1,2], k = 2`

**Output:** `7`

**Explanation:**

From the second row, we can take at most 2 elements. The elements taken are 4 and 3.  
The maximum possible sum of at most 2 selected elements is `4 + 3 = 7`.


## Constraints:

- `n == grid.length == limits.length`
- `m == grid[i].length`
- `1 <= n, m <= 500`
- `0 <= grid[i][j] <= 10^5`
- `0 <= limits[i] <= m`
- `0 <= k <= min(n * m, sum(limits))`



# 3449. Maximize the Minimum Game Score
困难


## 提示
You are given an array `points` of size `n` and an integer `m`. There is another array `gameScore` of size `n`, where `gameScore[i]` represents the score achieved at the `i`th game. Initially, `gameScore[i] == 0` for all `i`.

You start at index `-1`, which is outside the array (before the first position at index `0`). You can make at most `m` moves. In each move, you can either:

- Increase the index by `1` and add `points[i]` to `gameScore[i]`.
- Decrease the index by `1` and add `points[i]` to `gameScore[i]`.

Note that the index must always remain within the bounds of the array after the first move.

Return the maximum possible minimum value in `gameScore` after at most `m` moves.

### Example 1:

**Input:** `points = [2,4], m = 3`

**Output:** `4`

**Explanation:**

Initially, index `i = -1` and `gameScore = [0, 0]`.

| Move          | Index | gameScore |
|---------------|-------|-----------|
| Increase i    | 0     | [2, 0]    |
| Increase i    | 1     | [2, 4]    |
| Decrease i    | 0     | [4, 4]    |

The minimum value in `gameScore` is `4`, and this is the maximum possible minimum among all configurations. Hence, `4` is the output.


## Constraints:

- `2 <= n == points.length <= 5 * 10^4`
- `1 <= points[i] <= 10^6`
- `1 <= m <= 10^9`


## 三、深度搜索优先
# 3387. Maximize Amount After Two Days of Conversions
中等


## 提示
You are given a string `initialCurrency`, and you start with `1.0` of `initialCurrency`.

You are also given four arrays with currency pairs (strings) and rates (real numbers):

- `pairs1[i] = [startCurrencyi, targetCurrencyi]` denotes that you can convert from `startCurrencyi` to `targetCurrencyi` at a rate of `rates1[i]` on day 1.
- `pairs2[i] = [startCurrencyi, targetCurrencyi]` denotes that you can convert from `startCurrencyi` to `targetCurrencyi` at a rate of `rates2[i]` on day 2.

Also, each `targetCurrency` can be converted back to its corresponding `startCurrency` at a rate of `1 / rate`.

You can perform any number of conversions, including zero, using `rates1` on day 1, followed by any number of additional conversions, including zero, using `rates2` on day 2.

Return the maximum amount of `initialCurrency` you can have after performing any number of conversions on both days in order.

**Note:** Conversion rates are valid, and there will be no contradictions in the rates for either day. The rates for the days are independent of each other.

### Example 1:

**Input:**  
`initialCurrency = "EUR", pairs1 = [["EUR","USD"],["USD","JPY"]], rates1 = [2.0,3.0], pairs2 = [["JPY","USD"],["USD","CHF"],["CHF","EUR"]], rates2 = [4.0,5.0,6.0]`

**Output:**  
`720.00000`

**Explanation:**

To get the maximum amount of EUR, starting with 1.0 EUR:

**On Day 1:**
- Convert EUR to USD to get 2.0 USD.
- Convert USD to JPY to get 6.0 JPY.

**On Day 2:**
- Convert JPY to USD to get 24.0 USD.
- Convert USD to CHF to get 120.0 CHF.
- Finally, convert CHF to EUR to get 720.0 EUR.


## Constraints:

- `1 <= initialCurrency.length <= 3`
- `initialCurrency` consists only of uppercase English letters.
- `1 <= n == pairs1.length <= 10`
- `1 <= m == pairs2.length <= 10`
- `pairs1[i] == [startCurrencyi, targetCurrencyi]`
- `pairs2[i] == [startCurrencyi, targetCurrencyi]`
- `1 <= startCurrencyi.length, targetCurrencyi.length <= 3`
- `startCurrencyi` and `targetCurrencyi` consist only of uppercase English letters.
- `rates1.length == n`
- `rates2.length == m`
- `1.0 <= rates1[i], rates2[i] <= 10.0`
- The input is generated such that there are no contradictions or cycles in the conversion graphs for either day.
- The input is generated such that the output is at most `5 * 10^10`.



# 3425. Longest Special Path
困难


## 提示
You are given an undirected tree rooted at node 0 with n nodes numbered from 0 to n - 1, represented by a 2D array `edges` of length n - 1, where `edges[i] = [ui, vi, lengthi]` indicates an edge between nodes `ui` and `vi` with length `lengthi`. You are also given an integer array `nums`, where `nums[i]` represents the value at node `i`.

A special path is defined as a downward path from an ancestor node to a descendant node such that all the values of the nodes in that path are unique.

Note that a path may start and end at the same node.

Return an array `result` of size 2, where `result[0]` is the length of the longest special path, and `result[1]` is the minimum number of nodes in all possible longest special paths.

### Example 1:

**Input:**  
`edges = [[0,1,2],[1,2,3],[1,3,5],[1,4,4],[2,5,6]], nums = [2,1,2,1,3,1]`

**Output:**  
`[6,2]`

**Explanation:**

In the image below, nodes are colored by their corresponding values in `nums`.
![3425的图片](../图片/3425.jpeg)

The longest special paths are `2 -> 5` and `0 -> 1 -> 4`, both having a length of 6. The minimum number of nodes across all longest special paths is 2.


## Constraints:

- `2 <= n <= 5 * 10^4`
- `edges.length == n - 1`
- `edges[i].length == 3`
- `0 <= ui, vi < n`
- `1 <= lengthi <= 103`
- `nums.length == n`
- `0 <= nums[i] <= 5 * 10^4`
- The input is generated such that `edges` represents a valid tree.


## 四、二分查找
# 3477. Fruits Into Baskets II

简单

## 提示

You are given two arrays of integers, `fruits` and `baskets`, each of length `n`, where `fruits[i]` represents the quantity of the ith type of fruit, and `baskets[j]` represents the capacity of the jth basket.

From left to right, place the fruits according to these rules:

- Each fruit type must be placed in the leftmost available basket with a capacity greater than or equal to the quantity of that fruit type.
- Each basket can hold only one type of fruit.
- If a fruit type cannot be placed in any basket, it remains unplaced.

Return the number of fruit types that remain unplaced after all possible allocations are made.

## Example 1:

**Input:** `fruits = [4,2,5], baskets = [3,5,4]`

**Output:** `1`

**Explanation:**

- `fruits[0] = 4` is placed in `baskets[1] = 5`.
- `fruits[1] = 2` is placed in `baskets[0] = 3`.
- `fruits[2] = 5` cannot be placed in `baskets[2] = 4`.

Since one fruit type remains unplaced, we return `1`.


## Constraints:

- `n == fruits.length == baskets.length`
- `1 <= n <= 100`
- `1 <= fruits[i], baskets[i] <= 1000`

# 3479. Fruits Into Baskets III

中等


## 提示

You are given two arrays of integers, `fruits` and `baskets`, each of length `n`, where `fruits[i]` represents the quantity of the ith type of fruit, and `baskets[j]` represents the capacity of the jth basket.

From left to right, place the fruits according to these rules:

- Each fruit type must be placed in the leftmost available basket with a capacity greater than or equal to the quantity of that fruit type.
- Each basket can hold only one type of fruit.
- If a fruit type cannot be placed in any basket, it remains unplaced.

Return the number of fruit types that remain unplaced after all possible allocations are made.

## Example 1:

**Input:** `fruits = [4,2,5], baskets = [3,5,4]`

**Output:** `1`

**Explanation:**

- `fruits[0] = 4` is placed in `baskets[1] = 5`.
- `fruits[1] = 2` is placed in `baskets[0] = 3`.
- `fruits[2] = 5` cannot be placed in `baskets[2] = 4`.

Since one fruit type remains unplaced, we return `1`.


## Constraints:

- `n == fruits.length == baskets.length`
- `1 <= n <= 10^5`
- `1 <= fruits[i], baskets[i] <= 10^9`

# 3455. Shortest Matching Substring

困难


## 提示

You are given a string `s` and a pattern string `p`, where `p` contains exactly two '*' characters.

The '*' in `p` matches any sequence of zero or more characters.

Return the length of the shortest substring in `s` that matches `p`. If there is no such substring, return -1.

Note: The empty substring is considered valid.

## Example 1:

**Input:** `s = "abaacbaecebce", p = "ba*c*ce"`

**Output:** `8`

**Explanation:**

The shortest matching substring of `p` in `s` is `"baecebce"`.


## Constraints:

- `1 <= s.length <= 10^5`
- `2 <= p.length <= 10^5`
- `s` contains only lowercase English letters.
- `p` contains only lowercase English letters and exactly two '*'.


## 五、广度搜索优先
# 3286. Find a Safe Walk Through a Grid

**中等**


## 提示

You are given an `m x n` binary matrix `grid` and an integer `health`.

You start on the upper-left corner `(0, 0)` and would like to get to the lower-right corner `(m - 1, n - 1)`.

You can move up, down, left, or right from one cell to another adjacent cell as long as your health remains positive.

Cells `(i, j)` with `grid[i][j] = 1` are considered unsafe and reduce your health by 1.

Return `true` if you can reach the final cell with a health value of 1 or more, and `false` otherwise.

## Example 1:

**Input:** `grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]], health = 1`

**Output:** `true`

**Explanation:**

The final cell can be reached safely by walking along the gray cells below.
![3286](Collected_Code_Snippets/Leetcode_Task/图片/3286.png)


## Constraints:

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 50`
- `2 <= m * n`
- `1 <= health <= m + n`
- `grid[i][j]` is either 0 or 1.


## 六、回溯
# 3376. Minimum Time to Break Locks I

中等


## 提示

Bob is stuck in a dungeon and must break `n` locks, each requiring some amount of energy to break. The required energy for each lock is stored in an array called `strength` where `strength[i]` indicates the energy needed to break the `i`th lock.

To break a lock, Bob uses a sword with the following characteristics:

- The initial energy of the sword is 0.
- The initial factor `x` by which the energy of the sword increases is 1.
- Every minute, the energy of the sword increases by the current factor `x`.
- To break the `i`th lock, the energy of the sword must reach at least `strength[i]`.
- After breaking a lock, the energy of the sword resets to 0, and the factor `x` increases by a given value `k`.

Your task is to determine the minimum time in minutes required for Bob to break all `n` locks and escape the dungeon.

Return the minimum time required for Bob to break all `n` locks.

## Examples

### Example 1:

**Input:** 
```plaintext
strength = [3,4,1], k = 1
```

**Output:** 
```plaintext
4
```

**Explanation:**

| Time | Energy | x | Action             | Updated x |
|------|--------|---|--------------------|-----------|
| 0    | 0      | 1 | Nothing            | 1         |
| 1    | 1      | 1 | Break 3rd Lock     | 2         |
| 2    | 2      | 2 | Nothing            | 2         |
| 3    | 4      | 2 | Break 2nd Lock     | 3         |
| 4    | 3      | 3 | Break 1st Lock     | 3         |

The locks cannot be broken in less than 4 minutes; thus, the answer is 4.


## Constraints

- `n == strength.length`
- `1 <= n <= 8`
- `1 <= K <= 10`
- `1 <= strength[i] <= 10^6`

# 3348. Smallest Divisible Digit Product II

困难


## 提示

You are given a string `num` which represents a positive integer, and an integer `t`.

A number is called zero-free if none of its digits are 0.

Return a string representing the smallest zero-free number greater than or equal to `num` such that the product of its digits is divisible by `t`. If no such number exists, return `"-1"`.

## Examples

### Example 1:

**Input:** 
```plaintext
num = "1234", t = 256
```

**Output:** 
```plaintext
"1488"
```

**Explanation:**

The smallest zero-free number that is greater than `1234` and has the product of its digits divisible by `256` is `1488`, with the product of its digits equal to `256`.


## Constraints

- `2 <= num.length <= 2 * 10^5`
- `num` consists only of digits in the range `['0', '9']`.
- `num` does not contain leading zeros.
- `1 <= t <= 10^14`


## 七、递归
# 3304. Find the K-th Character in String Game I

**简单**


## 提示

Alice and Bob are playing a game. Initially, Alice has a string `word = "a"`.

You are given a positive integer `k`.

Now Bob will ask Alice to perform the following operation forever:

Generate a new string by changing each character in `word` to its next character in the English alphabet, and append it to the original word. For example, performing the operation on `"c"` generates `"cd"` and performing the operation on `"zb"` generates `"zbac"`.

Return the value of the k-th character in `word`, after enough operations have been done for `word` to have at least `k` characters.

Note that the character `'z'` can be changed to `'a'` in the operation.

## Example 1:

**Input:** `k = 5`

**Output:** `"b"`

**Explanation:**

Initially, `word = "a"`. We need to do the operation three times:

- Generated string is `"b"`, `word` becomes `"ab"`.
- Generated string is `"bc"`, `word` becomes `"abbc"`.
- Generated string is `"bccd"`, `word` becomes `"abbcbccd"`.


## Constraints:

`1 <= k <= 500`

