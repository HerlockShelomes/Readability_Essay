## 算法

包含动态规划，贪心，深度搜索优先，二分查找，光度搜索优先，回溯，递归，分治，记忆化搜索，归并排序，快速选择。



## 动态规划
# 3473. Sum of K Subarrays With Length at Least M
中等


## 提示
You are given an integer array `nums` and two integers `k` and `m`.

Return the maximum sum of `k` non-overlapping subarrays of `nums`, where each subarray has a length of at least `m`.

### Example 1:

**Input:** `nums = [1,2,-1,3,3,4], k = 2, m = 2`

**Output:** `13`

**Explanation:**

The optimal choice is:

Subarray `nums[3..5]` with sum `3 + 3 + 4 = 10` (length is 3 >= m).  
Subarray `nums[0..1]` with sum `1 + 2 = 3` (length is 2 >= m).  
The total sum is `10 + 3 = 13`.


## Constraints:

- `1 <= nums.length <= 2000`
- `-10^4 <= nums[i] <= 10^4`
- `1 <= k <= floor(nums.length / m)`
- `1 <= m <= 3`


## 贪心
# 3402. Minimum Operations to Make Columns Strictly Increasing
简单


## 提示
You are given a `m x n` matrix `grid` consisting of non-negative integers.

In one operation, you can increment the value of any `grid[i][j]` by 1.

Return the minimum number of operations needed to make all columns of `grid` strictly increasing.

### Example 1:

**Input:** `grid = [[3,2],[1,3],[3,4],[0,1]]`

**Output:** `15`

**Explanation:**

To make the 0th column strictly increasing, we can apply 3 operations on `grid[1][0]`, 2 operations on `grid[2][0]`, and 6 operations on `grid[3][0]`.  
To make the 1st column strictly increasing, we can apply 4 operations on `grid[3][1]`.



## Constraints:

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 50`
- `0 <= grid[i][j] < 2500`




# 3462. Maximum Sum With at Most K Elements
中等

## 提示
You are given a `2D` integer matrix `grid` of size `n x m`, an integer array `limits` of length `n`, and an integer `k`. The task is to find the maximum sum of at most `k` elements from the matrix `grid` such that:

The number of elements taken from the `i`th row of `grid` does not exceed `limits[i]`.

Return the maximum sum.

### Example 1:

**Input:** `grid = [[1,2],[3,4]], limits = [1,2], k = 2`

**Output:** `7`

**Explanation:**

From the second row, we can take at most 2 elements. The elements taken are 4 and 3.  
The maximum possible sum of at most 2 selected elements is `4 + 3 = 7`.


## Constraints:

- `n == grid.length == limits.length`
- `m == grid[i].length`
- `1 <= n, m <= 500`
- `0 <= grid[i][j] <= 10^5`
- `0 <= limits[i] <= m`
- `0 <= k <= min(n * m, sum(limits))`



# 3449. Maximize the Minimum Game Score
困难


## 提示
You are given an array `points` of size `n` and an integer `m`. There is another array `gameScore` of size `n`, where `gameScore[i]` represents the score achieved at the `i`th game. Initially, `gameScore[i] == 0` for all `i`.

You start at index `-1`, which is outside the array (before the first position at index `0`). You can make at most `m` moves. In each move, you can either:

- Increase the index by `1` and add `points[i]` to `gameScore[i]`.
- Decrease the index by `1` and add `points[i]` to `gameScore[i]`.

Note that the index must always remain within the bounds of the array after the first move.

Return the maximum possible minimum value in `gameScore` after at most `m` moves.

### Example 1:

**Input:** `points = [2,4], m = 3`

**Output:** `4`

**Explanation:**

Initially, index `i = -1` and `gameScore = [0, 0]`.

| Move          | Index | gameScore |
|---------------|-------|-----------|
| Increase i    | 0     | [2, 0]    |
| Increase i    | 1     | [2, 4]    |
| Decrease i    | 0     | [4, 4]    |

The minimum value in `gameScore` is `4`, and this is the maximum possible minimum among all configurations. Hence, `4` is the output.


## Constraints:

- `2 <= n == points.length <= 5 * 10^4`
- `1 <= points[i] <= 10^6`
- `1 <= m <= 10^9`


## 深度搜索优先
# 3387. Maximize Amount After Two Days of Conversions
中等


## 提示
You are given a string `initialCurrency`, and you start with `1.0` of `initialCurrency`.

You are also given four arrays with currency pairs (strings) and rates (real numbers):

- `pairs1[i] = [startCurrencyi, targetCurrencyi]` denotes that you can convert from `startCurrencyi` to `targetCurrencyi` at a rate of `rates1[i]` on day 1.
- `pairs2[i] = [startCurrencyi, targetCurrencyi]` denotes that you can convert from `startCurrencyi` to `targetCurrencyi` at a rate of `rates2[i]` on day 2.

Also, each `targetCurrency` can be converted back to its corresponding `startCurrency` at a rate of `1 / rate`.

You can perform any number of conversions, including zero, using `rates1` on day 1, followed by any number of additional conversions, including zero, using `rates2` on day 2.

Return the maximum amount of `initialCurrency` you can have after performing any number of conversions on both days in order.

**Note:** Conversion rates are valid, and there will be no contradictions in the rates for either day. The rates for the days are independent of each other.

### Example 1:

**Input:**  
`initialCurrency = "EUR", pairs1 = [["EUR","USD"],["USD","JPY"]], rates1 = [2.0,3.0], pairs2 = [["JPY","USD"],["USD","CHF"],["CHF","EUR"]], rates2 = [4.0,5.0,6.0]`

**Output:**  
`720.00000`

**Explanation:**

To get the maximum amount of EUR, starting with 1.0 EUR:

**On Day 1:**
- Convert EUR to USD to get 2.0 USD.
- Convert USD to JPY to get 6.0 JPY.

**On Day 2:**
- Convert JPY to USD to get 24.0 USD.
- Convert USD to CHF to get 120.0 CHF.
- Finally, convert CHF to EUR to get 720.0 EUR.


## Constraints:

- `1 <= initialCurrency.length <= 3`
- `initialCurrency` consists only of uppercase English letters.
- `1 <= n == pairs1.length <= 10`
- `1 <= m == pairs2.length <= 10`
- `pairs1[i] == [startCurrencyi, targetCurrencyi]`
- `pairs2[i] == [startCurrencyi, targetCurrencyi]`
- `1 <= startCurrencyi.length, targetCurrencyi.length <= 3`
- `startCurrencyi` and `targetCurrencyi` consist only of uppercase English letters.
- `rates1.length == n`
- `rates2.length == m`
- `1.0 <= rates1[i], rates2[i] <= 10.0`
- The input is generated such that there are no contradictions or cycles in the conversion graphs for either day.
- The input is generated such that the output is at most `5 * 10^10`.



# 3425. Longest Special Path
困难


## 提示
You are given an undirected tree rooted at node 0 with n nodes numbered from 0 to n - 1, represented by a 2D array `edges` of length n - 1, where `edges[i] = [ui, vi, lengthi]` indicates an edge between nodes `ui` and `vi` with length `lengthi`. You are also given an integer array `nums`, where `nums[i]` represents the value at node `i`.

A special path is defined as a downward path from an ancestor node to a descendant node such that all the values of the nodes in that path are unique.

Note that a path may start and end at the same node.

Return an array `result` of size 2, where `result[0]` is the length of the longest special path, and `result[1]` is the minimum number of nodes in all possible longest special paths.

### Example 1:

**Input:**  
`edges = [[0,1,2],[1,2,3],[1,3,5],[1,4,4],[2,5,6]], nums = [2,1,2,1,3,1]`

**Output:**  
`[6,2]`

**Explanation:**

In the image below, nodes are colored by their corresponding values in `nums`.
![3425](Readability_Essay/Collected_Code_Snippets/Leetcode_Task/图片/3425.jpeg)

The longest special paths are `2 -> 5` and `0 -> 1 -> 4`, both having a length of 6. The minimum number of nodes across all longest special paths is 2.


## Constraints:

- `2 <= n <= 5 * 10^4`
- `edges.length == n - 1`
- `edges[i].length == 3`
- `0 <= ui, vi < n`
- `1 <= lengthi <= 103`
- `nums.length == n`
- `0 <= nums[i] <= 5 * 10^4`
- The input is generated such that `edges` represents a valid tree.
